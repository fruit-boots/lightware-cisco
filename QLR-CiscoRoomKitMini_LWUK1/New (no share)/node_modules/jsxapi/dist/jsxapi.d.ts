/// <reference types="node" />
import { EventEmitter } from 'events';

declare interface Backend extends EventEmitter {
    close(): void;
    execute(request: XapiRequest): Promise<void>;
}

declare class Component {
    readonly xapi: XAPI;
    prefix: string;
    constructor(xapi: XAPI);
    normalizePath(path: Path): (string | number)[];
}

declare class Config extends Config_base implements Component, Listenable, Gettable, Settable {
    readonly xapi: XAPI;
    prefix: string;
    normalizePath: (path: Path) => Array<string | number>;
    on: <T = any>(path: Path, listener: Listener<T>) => Registration;
    once: <T = any>(path: Path, listener: Listener<T>) => Registration;
    off: () => void;
    get: <T = any>(path: Path) => Promise<T>;
    set: (path: Path, value: number | string) => Promise<any>;
    constructor(xapi: XAPI);
}

declare const Config_base: any;

export declare const connect: import("./connect").Connect;

declare function defaultInterceptor<T>(payload: T, emit: (payload: T) => void): void;

declare class Event extends Event_base implements Component, Listenable {
    readonly xapi: XAPI;
    prefix: string;
    normalizePath: (path: Path) => Array<string | number>;
    on: <T = any>(path: Path, listener: Listener<T>) => Registration;
    once: <T = any>(path: Path, listener: Listener<T>) => Registration;
    off: () => void;
    constructor(xapi: XAPI);
}

declare const Event_base: any;

declare class Feedback {
    readonly xapi: XAPI;
    readonly interceptor: typeof defaultInterceptor;
    readonly eventEmitter: EventEmitter;
    private subscriptions;
    constructor(xapi: XAPI, interceptor?: typeof defaultInterceptor);
    on(path: Path, listener: Listener): Registration;
    once<T = any>(path: Path, listener: Listener): Registration;
    off(): void;
    dispatch(data: any): this;
    group(handlers: Handler[]): FeedbackGroup;
}

declare class FeedbackGroup {
    private handlers;
    constructor(handlers: Handler[]);
    add(handler: Handler): this;
    remove(handler: Handler): this;
    off(): this;
}

declare class Gettable {
    xapi: XAPI;
    normalizePath: typeof normalizePath;
    get<T = any>(path: Path): Promise<T>;
}

declare type Handler = () => void;

declare class Listenable {
    xapi: XAPI;
    normalizePath: typeof normalizePath;
    on<T = any>(path: Path, listener: Listener<T>): import("./feedback").Registration;
    once<T = any>(path: Path, listener: Listener<T>): import("./feedback").Registration;
    off(): void;
}

declare type Listener<T = any> = (ev: T, root: any) => void;

declare type NormalizedPath = Array<string | number>;

declare function normalizePath(path: Path): NormalizedPath;

declare type Path = string | string[];

declare interface Registration {
    (): void;
    registration: Promise<{
        Id: string;
    }>;
}

declare class Settable {
    xapi: XAPI;
    normalizePath: typeof normalizePath;
    set(path: Path, value: number | string): Promise<unknown>;
}

declare class Status extends Status_base implements Component, Listenable, Gettable {
    readonly xapi: XAPI;
    prefix: string;
    normalizePath: (path: Path) => Array<string | number>;
    on: <T = any>(path: Path, listener: Listener<T>) => Registration;
    once: <T = any>(path: Path, listener: Listener<T>) => Registration;
    off: () => void;
    get: <T = any>(path: Path) => Promise<T>;
    constructor(xapi: XAPI);
}

declare const Status_base: any;

export declare interface XAPI {
    on(event: 'error', listener: (error: Error) => void): this;
    on(event: 'ready', listener: (xapi: XAPI) => void): this;
    on(event: string, listener: () => {}): this;
}

export declare class XAPI extends EventEmitter {
    private readonly backend;
    feedback: Feedback;
    config: Config;
    status: Status;
    event: Event;
    Command: any;
    Config: any;
    Status: any;
    Event: any;
    private requestId;
    private requests;
    constructor(backend: Backend, options?: XapiOptions);
    close(): this;
    command<T = any>(path: Path, params?: any, body?: string): Promise<T>;
    execute<T>(method: string, params: any): Promise<T>;
    private handleResponse;
    private nextRequestId;
}

declare interface XapiOptions {
    feedbackInterceptor?: (data?: any) => void;
    seal: boolean;
}

declare interface XapiRequest {
    id?: string;
    method: string;
    jsonrpc: string;
    params?: any;
}

export { }
