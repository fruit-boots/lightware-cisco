"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var duplex_passthrough_1 = __importDefault(require("duplex-passthrough"));
var ssh2_1 = require("ssh2");
var log_1 = __importDefault(require("../log"));
if (!duplex_passthrough_1.default.prototype.on.isPatched) {
    var origOn_1 = duplex_passthrough_1.default.prototype.on;
    var patchedFunc = function on() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        origOn_1.call.apply(origOn_1, __spreadArrays([this], args));
        return this;
    };
    patchedFunc.isPatched = true;
    duplex_passthrough_1.default.prototype.on = patchedFunc;
    duplex_passthrough_1.default.prototype.addListener = patchedFunc;
}
function connectSSH(options) {
    var closing = false;
    var mergedOpts = Object.assign({
        client: new ssh2_1.Client(),
        transport: new duplex_passthrough_1.default(),
    }, options);
    var client = mergedOpts.client, password = mergedOpts.password, transport = mergedOpts.transport;
    delete mergedOpts.password;
    function onKeyboardInteractive(n, i, il, p, finish) {
        finish([password]);
    }
    function onReady() {
        log_1.default.debug('[SSH] connection ready');
        client.shell(false, function (err, sshStream) {
            if (err) {
                log_1.default.error('[SSH] shell error:', err);
                transport.emit('error', err);
                return;
            }
            log_1.default.debug('[SSH] shell ready');
            sshStream
                .on('error', function (error) {
                transport.emit('error', error);
            })
                .on('end', function () {
                if (!closing) {
                    transport.emit('error', 'Connection terminated remotely');
                }
            })
                .on('close', function () {
                transport.emit('close');
            });
            if (options.command) {
                client.exec(options.command, function (binaryErr, binaryStream) {
                    if (binaryErr) {
                        log_1.default.error('[SSH] exec error:', err);
                        transport.emit('error', binaryErr);
                        return;
                    }
                    binaryStream.on('error', function (error) {
                        log_1.default.error('[SSH] stream error:', error);
                        transport.emit('error', error);
                    });
                    log_1.default.debug('[SSH] exec ready');
                    transport.wrapStream(binaryStream);
                });
                return;
            }
            transport.wrapStream(sshStream);
        });
    }
    client
        .on('keyboard-interactive', onKeyboardInteractive)
        .on('ready', onReady)
        .on('error', function (error) {
        transport.emit('error', error.level);
    })
        .on('close', function () {
        transport.emit('close');
    })
        .connect(Object.assign({ tryKeyboard: true }, mergedOpts));
    transport.close = function () {
        closing = true;
        client.end();
    };
    return transport;
}
exports.default = connectSSH;
